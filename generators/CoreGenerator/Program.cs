using funclib.Components.Core.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using static funclib.core;

namespace CoreGenerator
{
    public class Program
    {
        const string MODIFIER = ":modifier";
        const string NAME = ":name";
        const string FULLNAME = ":full-name";
        const string COMMENTS = ":comments";
        const string PRIVATENAME = ":private-name";
        const string TYPEDPARAMTERS = ":typed-parameters";
        const string RETURNTYPE = ":return-type";
        const string PARAMETERS = ":parameters";
        const string PARAMETERLIST = ":parameter-list";
        const string ISMACROFUNCTION = ":macro-function?";
        const string CLASSNAME = ":class-name";
        const string PARENT = ":parent";

        static void Main(string[] args)
        {
            var sw = Stopwatch.StartNew();
            var dir = new DirectoryInfo(AppContext.BaseDirectory).Parent.Parent.Parent.Parent.Parent.FullName + @"\src\funclib";
            var files = filter(ExtensionsPredicate, Directory.GetFiles(dir + @"\Components\Core", "*", SearchOption.AllDirectories));
            var syntax = filter(ClassDeclarationsPredicate, flatten(map(GetDescendantNodes<ClassDeclarationSyntax>(), map(ConvertToSyntaxNode, files))));

            var lines = new List<string>();

            lines.Add("//------------------------------------------------------------------------------");
            lines.Add("// <auto-generated>");
            lines.Add("//     This code was generated by a tool on {DateTime.Now}");
            lines.Add("//");
            lines.Add("//     Changes to this file may cause incorrect behavior and will be lost if");
            lines.Add("//     the code is regenerated.");
            lines.Add("// </auto-generated>");
            lines.Add("//------------------------------------------------------------------------------");
            lines.Add("using funclib.Collections;");
            lines.Add("using funclib.Components.Core;");
            lines.Add("using funclib.Components.Core.Generic;");
            lines.Add("using System;");
            lines.Add(Environment.NewLine);
            lines.Add("namespace funclib");
            lines.Add("{");
            lines.Add("\tpublic static class Core");
            lines.Add("\t{");

            var l = ((object[])toArray(flatten(map(Build, syntax)))).Select(x => $"\t\t{x}");

            lines.AddRange(l);
            lines.Add("\t}");
            lines.Add("}");

            var source = dir + @"\Core2.cs";
            File.WriteAllLines(source, lines);

            Console.WriteLine($"Time Elapsed: {sw.Elapsed}");
            Console.WriteLine("========== Finished ==========");
            Console.ReadLine();
        }

        // remove this once this has been generated!
        public static Function<object, object> Func(Func<object, object> x) => new Function<object, object>(x);
        public static Function<object, object, object> Func(Func<object, object, object> x) => new Function<object, object, object>(x);
        public static Function<object, object, object, object> Func(Func<object, object, object, object> x) => new Function<object, object, object, object>(x);
        public static Function<object, object, object, object, object> Func(Func<object, object, object, object, object> x) => new Function<object, object, object, object, object>(x);


        public static object ExtensionsPredicate => Func(file => Path.GetExtension((string)file) == ".cs");
        public static object ConvertToSyntaxNode => Func(file => CSharpSyntaxTree.ParseText(File.ReadAllText((string)file)).GetRoot());
        public static object GetDescendantNodes<T>() => Func(node => listS(((CSharpSyntaxNode)node).DescendantNodes().OfType<T>()));
        public static object IsChildOfNamespace => Func(node => node != null && ((SyntaxNode)node).Parent.Kind() == SyntaxKind.NamespaceDeclaration);
        public static object IsNotAnAbstractClass => Func(node => node != null && !((BaseTypeDeclarationSyntax)node).Modifiers.Any(x => x.Text == "abstract"));
        public static object ClassDeclarationsPredicate => Func(node => and(identity(node), invoke(IsChildOfNamespace, node), invoke(IsNotAnAbstractClass, node)));
        public static object IsInvokeIdentitifer => Func(map => get(map, NAME).Equals("Invoke"));
        public static object IsPublic => Func(map => get(map, MODIFIER).Equals("public"));
        public static object MethodDeclarationPredicate(object node) => Func(map => and(invoke(IsInvokeIdentitifer, map), invoke(IsPublic, map), invoke(IsChildOf(node), map)));
        public static object IsChildOf(object node) => Func(map => get(map, PARENT) == node);

        public static object Build => Func(node =>
        {
            var @class = invoke(GetClassDeclaration, node);
            var constructors = filter(IsPublic, map(GetConstructorDeclaration(@class), invoke(GetDescendantNodes<ConstructorDeclarationSyntax>(), node)));
            var methods = filter(MethodDeclarationPredicate(node), map(GetMethodDeclaration(@class), invoke(GetDescendantNodes<MethodDeclarationSyntax>(), node)));

            var className = get(@class, NAME);
            var isMacroFunction = get(@class, ISMACROFUNCTION);
            var typedParameters = get(@class, TYPEDPARAMTERS);

            var v = conj(vector(), $"#region {className}{typedParameters}");

            if (className.Equals("Function") || className.Equals("FunctionParams"))
            {
                v = reduce(Conj, v, flatten(map(BuildStatement(GetFunctionStatement), constructors)));
            }
            else if (className.Equals("LazySeq"))
            {
                v = reduce(Conj, v, flatten(map(BuildStatement(GetLazySeqStatement), constructors)));
            }
            else if ((bool)truthy(isMacroFunction))
            {
                v = reduce(Conj, v, flatten(map(BuildStatement(GetMacroFunctionStatement), constructors)));
            }
            else
            {
                v = apply(Conj, v, invoke(BuildClassStatement, @class));
                v = reduce(Conj, v, flatten(map(BuildStatement(GetMethodStatement), methods)));
            }

            v = conj(v, "#endregion");

            return v;
        });

        public static object BuildClassStatement => Func(map =>
        {
            var v = conj(vector(), invoke(GetPrivatePropertyStatement, map));
            v = apply(Conj, v, get(map, COMMENTS));
            v = conj(v, invoke(GetPropertyStatement, map));
            return v;
        });

        public static object BuildStatement(object f) => Func(map =>
        {
            var v = vector();
            v = apply(Conj, v, get(map, COMMENTS));
            v = conj(v, invoke(f, map));
            return v;
        });

        public static object GetClassDeclaration => Func(node =>
        {
            var declaration = (ClassDeclarationSyntax)node;

            return arrayMap(
                MODIFIER, GetModifier(declaration.Modifiers),
                NAME, declaration.Identifier.Text,
                FULLNAME, GetFullyQualifiedName(declaration),
                COMMENTS, GetComments(declaration),
                PRIVATENAME, str("__", declaration.Identifier.Text.ToLower()),
                TYPEDPARAMTERS, declaration.TypeParameterList?.ToString(),
                ISMACROFUNCTION, declaration.DescendantNodes().OfType<BaseListSyntax>().FirstOrDefault().Types.ToString() == "IMacroFunction"
                );
        });

        public static object GetMethodDeclaration(object classMap) => Func(node =>
        {
            var declaration = (MethodDeclarationSyntax)node;

            return arrayMap(
                CLASSNAME, get(classMap, NAME),
                MODIFIER, GetModifier(declaration.Modifiers),
                NAME, declaration.Identifier.Text,
                RETURNTYPE, declaration.ReturnType.ToString(),
                PARAMETERS, declaration.ParameterList.ToString(),
                PARAMETERLIST, GetParameterList(declaration.ParameterList),
                COMMENTS, GetComments(declaration),
                PARENT, declaration.Parent
                );
        });

        public static object GetConstructorDeclaration(object @class) => Func(node =>
        {
            var declaration = (ConstructorDeclarationSyntax)node;

            return arrayMap(
                CLASSNAME, get(@class, NAME),
                FULLNAME, get(@class, FULLNAME),
                MODIFIER, get(@class, MODIFIER),
                COMMENTS, GetComments(declaration),
                PARAMETERS, declaration.ParameterList.ToString(),
                PARAMETERLIST, GetParameterList(declaration.ParameterList),
                TYPEDPARAMTERS, get(@class, TYPEDPARAMTERS)
                );
        });

        public static object GetPropertyStatement => Func(map =>
        {
            var modifier = get(map, MODIFIER);
            var fullName = get(map, FULLNAME);
            var name = FixClassName(get(map, NAME));
            var privateName = get(map, PRIVATENAME);

            return $"{modifier} static {fullName} {name} => {privateName} ?? ({privateName} = new {fullName}());";
        });

        public static object GetPrivatePropertyStatement => Func(map =>
        {
            var fullName = get(map, FULLNAME);
            var privateName = get(map, PRIVATENAME);

            return $"static {fullName} {privateName};";
        });

        public static object GetMacroFunctionStatement => Func(constructorMap =>
        {
            var modifier = get(constructorMap, MODIFIER);
            var returnType = "object";
            var className = get(constructorMap, CLASSNAME);
            var fullName = get(constructorMap, FULLNAME);
            var typedParameters = get(constructorMap, TYPEDPARAMTERS);
            var constructorParameters = get(constructorMap, PARAMETERS);
            var parameterList = get(constructorMap, PARAMETERLIST);

            return $"{modifier} static {returnType} {className}{typedParameters}{constructorParameters} => new {fullName}{typedParameters}({parameterList}).Invoke();";
        });

        public static object GetFunctionStatement => Func(constructorMap =>
        {
            var name = "Func";
            var modifier = get(constructorMap, MODIFIER);
            var fullName = get(constructorMap, FULLNAME);
            var typedParameters = ReplaceObjectTypes(get(constructorMap, TYPEDPARAMTERS));
            var constructorParameters = ReplaceObjectTypes(get(constructorMap, PARAMETERS));
            var parameterList = get(constructorMap, PARAMETERLIST);

            return $"{modifier} static {fullName}{typedParameters} {name}{constructorParameters} => new {fullName}{typedParameters}({parameterList});";
        });

        public static object GetLazySeqStatement => Func((constructorMap) =>
        {
            var modifier = get(constructorMap, MODIFIER);
            var className = get(constructorMap, CLASSNAME);
            var fullName = get(constructorMap, FULLNAME);
            var typedParameters = get(constructorMap, TYPEDPARAMTERS);
            var constructorParameters = get(constructorMap, PARAMETERS);
            var parameterList = get(constructorMap, PARAMETERLIST);

            return $"{modifier} static {fullName}{typedParameters} {className}{typedParameters}{constructorParameters} => new {fullName}{typedParameters}({parameterList});";
        });

        public static object GetMethodStatement => Func((methodMap) =>
        {
            var modifier = get(methodMap, MODIFIER);
            var returnType = get(methodMap, RETURNTYPE);
            var className = get(methodMap, CLASSNAME);
            var methodName = get(methodMap, NAME);
            var parameterList = get(methodMap, PARAMETERLIST);
            var parameters = get(methodMap, PARAMETERS);

            return $"{modifier} static {returnType} {className}{parameters} => {FixClassName(className)}.{methodName}({parameterList});";
        });

        static List<string> GetComments(CSharpSyntaxNode node) =>
            node
                ?.GetLeadingTrivia()
                .FirstOrDefault(x => x.Kind() == SyntaxKind.SingleLineDocumentationCommentTrivia)
                .GetStructure()
                ?.GetText()
                ?.ToString()
                ?.Split(Environment.NewLine)
                ?.Select(x => x.Trim())
                ?.Where(x => !string.IsNullOrWhiteSpace(x))
                ?.ToList();

        static string GetModifier(SyntaxTokenList modifier) =>
            modifier.Count == 1
                ? modifier[0].Text
                : "internal";

        static string ReplaceObjectTypes(object str) =>
            str.ToString()
                .Replace("T1", "object")
                .Replace("T2", "object")
                .Replace("T3", "object")
                .Replace("T4", "object")
                .Replace("T5", "object")
                .Replace("T6", "object")
                .Replace("T7", "object")
                .Replace("T8", "object")
                .Replace("T9", "object")
                .Replace("T10", "object")
                .Replace("T11", "object")
                .Replace("T12", "object")
                .Replace("T13", "object")
                .Replace("T14", "object")
                .Replace("T15", "object")
                .Replace("T16", "object")
                .Replace("T17", "object")
                .Replace("TRest", "object")
                .Replace("TResult", "object");

        static string GetParameterList(ParameterListSyntax parameters) =>
            string.Join(", ",
                parameters.Parameters.Aggregate(new List<string>(), (a, c) =>
                {
                    a.Add(c.Identifier.Text);
                    return a;
                }));

        static string FixClassName(object className)
        {
            var name = className.ToString();

            name = System.Char.ToLowerInvariant(name[0]).ToString()
                + System.Char.ToLowerInvariant(name[1]).ToString()
                + name.Substring(2);

            switch (name)
            {
                case "class": return "@class";
                case "do": return "@do";
                case "char": return "@char";
                case "function": return "invoke";
                case "invokeFunction": return "invoke";
                case "uuID": return "uuid";
                case "rSeq": return "rseq";
            }

            return name;
        }

        static string GetFullyQualifiedName(ClassDeclarationSyntax classDeclaration)
        {
            if (!SyntaxNodeHelper.TryGetParentSyntax(classDeclaration, out NamespaceDeclarationSyntax ns)) return "";

            var nsName = ns.Name.ToString();
            return nsName + "." + classDeclaration.Identifier.ToString();
        }
    }
}
